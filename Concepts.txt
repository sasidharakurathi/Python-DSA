
1. Arrays (Lists)
    Two Pointers                                                                            -> Done
    Sliding Window                                                                          -> Done

2. Recursions
    Function or Method calling itself till a base condition is met is known as recursion.
    
    Problems:
        N Natural Numbers
        Factorial 
        Fibonacci
        Tribonacci
        isPowerOfTwo
        isPowerOfThree
        GCD
        LCM
        Power(x, n)

3. Stacks
    Stack                                                                                   -> Done
    Min Stack                                                                               -> Done
    Two Stacks in One Array                                                                 -> Done
    Stack Using Queues                                                                      -> Done
    K Stacks in a Single Array
    Stack with Middle Element Access (Use Double Linked List)                               -> Done

4. Queues
    Linear Queue                                                                            -> Done
    Circular Queue                                                                          -> Done
    Deque (Double-Ended)                                                                    -> Done
    Queue using Stack                                                                       -> Done

5. Hashing
    Hashmap (using dictionaries)                                                            -> Done
    Hashsets (using sets)                                                                   -> Done
    Hashing Strings                                                                         -> Done
    Custom Hashing for Tuples or Complex Key                                                -> Done

6. Linked Lists
    Singly Linked List                                                                      -> Done
    Doubly Linked List                                                                      -> Done
    Circular Linked List                                                                    -> Done
    Unrolled Linked List

7. Binary Search
    Standard Binary Search – Find an element in a sorted array.                             -> Done
    Lower Bound / Upper Bound – First element ≥ target / First element > target.            -> Done
    Search Insert Position – Where to insert an element to keep array sorted.               -> Done
    First and Last Occurrence – Especially useful for duplicates.                           -> Done

8. Tree

    Resources:
        https://youtu.be/W2WQBT8qu3Q?si=_lWjKYoiRCcLU18O

    1. Binary Tree
        Types:
            1. Full Binary Tree         - (Every node must have 0 or 2 Child nodes)
            2. Perfect Binary Tree      - (it is a Full Binary Tree + all the leaf nodes should be in same level)
            3. Complete Binary Tree     - (all the levels of the tree are filled completely except the lowest level nodes which are filled from as left as possible)
            4. Degenerate Binary        - (Every node must have 0 or 1 Child nodes)  
            5. Skewed Tree              - (Every node must have 0 or 1 Child nodes + all childs should be left or right of root node)
            6. Balanced Binary          - (Difference of all the 'left subtree and right subtree' should be in [-1,0,1] only)  


    2. Binary Search Tree (BST)
        - BST is an Binary Tree which can perform search operation in 'O(log n) Best case Time Complexity' or 'O(height) Worst case Time Complexity' 
        - Left subtree elements are always lesser than parent node
        - And Right subtree element are always greater than the parent node.

    Traversals:
        -> use inorder traversal for Binary Search Tree Validation          -   (implemented using stack or recursion)      -> Done
        -> use preorder traversal for tree cloning or expression trees      -   (implemented using stack or recursion)      -> Done
        -> use postorder traversal for deletion or evaluation               -   (implemented using stack or recursion)      -> Done
        -> use level order traversal for shortest path or tree width        -   (implemented using queue)                   -> Done

    Problems:
        Pre Order Traversal                                         -> Done
        In Order Traversal                                          -> Done
        Post Order Traversal                                        -> Done
        Level Order Traversal                                       -> Done
        Zig Zag Level Order Traversal                               -> Done
        Level Order Bottom Traversal                                -> Done
        Right Side View                                             -> Done
        Max Height                                                  -> Done
        Is Symmetric                                                -> Done
        Is Balanced                                                 -> Done
        Insert operation Binary Search Tree                         -> Done
        Search operation Binary Search Tree                         -> Done
        Delete operation Binary Search Tree                         -> Done
        Validate Binary Search Tree                                 -> Done
        Kth Smallest element in BST                                 -> Done

9. Heaps (Priority Queues)
    A Heap data structure is a Complete Binary Tree that satisfies the heap priority where any given node is:
        1. always greater than its child nodes  and the key of the root node is the largest among all other nodes. (Max Heap)       -> Done
        2. always smaller than its child nodes  and the key of the root node is the smallest among all other nodes. (Min Heap)      -> Done
        
10. Graphs
    A graph data structure is a collection of nodes that have data and are connected to other nodes.

    Graph Representation:
        1. Edges                                                                                                            -> Done
        2. Adjacency List                                                                                                   -> Done
        3. Adjacency Matrix                                                                                                 -> Done

    Graph Traversals:
        1. Breadth First Search   --> (implemented using Queues)                -> (also need Adjacency Lists)              -> Done
            -> It first traversals all of the neighbours for a node then moves to next node

        2. Depth First Search     --> (implemented using Stacks or Recursions)  -> (also need Adjacency Lists)              -> Done
            -> It first traversals the a full path and then chooses the next path recursively 

    Weighted Graphs:
        Shortest Path Algorithms:

            1. Dijkstra Algorithm: (Single Source Shortest Path) + (Only Positive Weights)                                  -> Done
                -> Dijkstra's Algorithm is a shortest path algorithm used to find the shortest path between two nodes in a graph
                -> We use "priority queue" (min heap) to perform Dijkstra's Algorithm.
                -> Dijkstra's Algorithm can not be performed on "Negative Weighted Graph".
            2. Bellman Ford Algorithm: (Single Source Shortest Path) + (Both Positive and Negative Weights)
            3. Floyd Warshall Algorithm: (All-pairs shortest path)

        Minimum Spanning Tree:
            Definition:
                A Minimum Spanning Tree of a connected, undirected graph is a subset of edges that:
                    1. Connects all the vertices (i.e., forms a spanning tree)
                    2. Has no cycles
                    3. Minimizes the total edge weight
            
            Note:
                If a graph as "n" nodes then it's corresponding spanning tree has "n-1" edges


            1. Prim's Algorithm                                                                                             -> Done
                -> implemented using "Min Heap" for efficiency .
                -> It can be implemented using Adjacency Matrix or Adjacency List.

            2. Kruskal's Algorithm                                                                                          -> Done
                -> It can be implemented using Edges List
                -> We sort the edges based on their Weights
                -> Then we find the union of the "node1" and "node2" of a edge, such that they do not form a cycle
                   It can be found by checking if the "parent node" of both "node1" and "node2" is same then they form a cycle. 

        Topological Sorting:
            Topological Sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every 
            directed edge u-v (node1-node2), vertex u (node1) comes before v (node2) in the ordering.

            1. Kahn's Algorithm                                                                                             -> Done
                -> Compute "indegree" for all the nodes
                -> Add all t he nodes with "indegree == 0" into the queue
                -> while queue is not empty:
                    -> pop a "node" from the queue
                    -> add that "node" to the result list (topological_order)
                    -> for each "neighbour" of that "node":
                        -> decrement the indegree of the "neighbour"
                        -> if indegree[neighbour] == 0 then add the "neighbour" to the queue
                -> if the length of the topological_order less than total nodes then there is a cycle in the graph, just return False.
                -> else return the topological_order


    Problems:
        1. Detect Cycle In an undirected graph. (implemented using DFS - recursion)                                         -> Done
        2. Network Delay Time. (implemented using "Dijkstra's Algorithm")                                                   -> Done
        3. Course Schedule. (implemented using "Kahn's Algorithm")                                                          -> Done
        4. Course Schedule II. (implemented using "Kahn's Algorithm")                                                       -> Done




11. Dynamic Programming
12. Back Tracking
13. Tries